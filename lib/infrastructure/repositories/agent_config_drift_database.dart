import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:plug_agente/infrastructure/datasources/agent_config_data_source.dart';

part 'agent_config_drift_database.g.dart';

// ConfigData is generated by Drift in agent_config_drift_database.g.dart
abstract class AgentConfigDataSource {
  Future<List<ConfigData>> getAllConfigs();
  Future<ConfigData?> getConfigById(String id);
  Future<ConfigData?> getCurrentConfig();
  // Insertable<ConfigData> allows passing either ConfigData or ConfigTableCompanion
  Future<ConfigData> saveConfig(Insertable<ConfigData> config);
  Future<void> deleteConfig(String id);
}

@DriftDatabase(tables: [ConfigTable])
class AppDatabase extends _$AppDatabase implements AgentConfigDataSource {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 5;

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) async {
      await m.createAll();
    },
    onUpgrade: (Migrator m, int from, int to) async {
      if (from < 2) {
        await m.addColumn(configTable, configTable.serverUrl);
        await m.addColumn(configTable, configTable.agentId);
      }
      if (from < 3) {
        await m.addColumn(
          configTable,
          configTable.authToken as GeneratedColumn<Object>,
        );
        await m.addColumn(
          configTable,
          configTable.refreshToken as GeneratedColumn<Object>,
        );
      }
      if (from < 4) {
        await m.addColumn(
          configTable,
          configTable.authUsername as GeneratedColumn<Object>,
        );
        await m.addColumn(
          configTable,
          configTable.authPassword as GeneratedColumn<Object>,
        );
      }
      if (from < 5) {
        await m.alterTable(
          TableMigration(
            configTable,
            columnTransformer: {configTable.odbcDriverName: const Constant('')},
            newColumns: [configTable.odbcDriverName],
          ),
        );
      }
    },
  );

  @override
  Future<List<ConfigData>> getAllConfigs() => select(configTable).get();

  @override
  Future<ConfigData?> getConfigById(String id) => (select(
    configTable,
  )..where((tbl) => tbl.id.equals(id))).getSingleOrNull();

  @override
  Future<ConfigData?> getCurrentConfig() =>
      (select(configTable)
            ..orderBy([
              (tbl) => OrderingTerm(
                expression: tbl.updatedAt,
                mode: OrderingMode.desc,
              ),
            ])
            ..limit(1))
          .getSingleOrNull();

  @override
  Future<ConfigData> saveConfig(Insertable<ConfigData> config) async {
    await into(configTable).insertOnConflictUpdate(config);
    // After insertOnConflictUpdate, fetch the saved config by extracting ID
    if (config is ConfigData) {
      final saved = await getConfigById(config.id);
      return saved ?? config;
    }
    // If ConfigTableCompanion, get the ID and fetch
    final companion = config as ConfigTableCompanion;
    final id = companion.id.value;
    final saved = await getConfigById(id);
    if (saved == null) {
      throw StateError('Config saved but could not retrieve it');
    }
    return saved;
  }

  @override
  Future<void> deleteConfig(String id) =>
      (delete(configTable)..where((tbl) => tbl.id.equals(id))).go();
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'agent_config.db'));
    return NativeDatabase(file);
  });
}
