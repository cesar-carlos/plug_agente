---
description: Dart Style Guide - Dart/Flutter conventions and best practices based on Effective Dart
globs: ["lib/**/*.dart", "test/**/*.dart"]
alwaysApply: true
---

# Dart Style Guide - Effective Dart

## Naming

### Classes and Types

- âœ… Use **PascalCase** for classes, types, and enums
  ```dart
  class UserService { }
  enum UserRole { }
  typedef UserCallback = void Function(User);
  ```

### Variables, Methods, and Parameters

- âœ… Use **camelCase** for variables, methods, and parameters
  ```dart
  String userName = 'John';
  void getUserData() { }
  void createUser(String userName) { }
  ```

### Constants

- âœ… Use **lowerCamelCase** for named constants (prefer `const` over `static final`)

  ```dart
  const maxRetries = 3;
  const defaultTimeout = Duration(seconds: 30);

  // For class constants
  static const String apiUrl = 'https://api.example.com';
  ```

### Libraries and Packages

- âœ… Use **lowercase_with_underscores** for file and folder names
  ```dart
  // File: user_service.dart
  // Folder: user_services/
  ```

### Private

- âœ… Use **underscore prefix** for private members
  ```dart
  final String _privateField;
  void _privateMethod() { }
  ```

## Types and Null Safety

### Type Declaration

- âœ… Prefer explicit types for public APIs

  ```dart
  // âœ… Good: explicit type
  String getUserName() => 'John';

  // âš ï¸ Avoid: inference in public APIs
  getUserName() => 'John';
  ```

### Null Safety

- âœ… Use null safety: avoid `null` when possible
- âœ… Use `?` only when necessary
- âœ… Use `!` only when absolutely safe
- âœ… Prefer `late` for late initialization over nullable `null`

```dart
// âœ… Good: non-nullable when possible
String userName = 'John';

// âœ… Good: nullable when necessary
String? optionalUserName;

// âœ… Good: late for late initialization
late String userName;
void init() {
  userName = 'John';
}

// âŒ Avoid: unnecessary null
String? userName = null; // Doesn't need to be nullable if it always has a value
```

### Initialization

- âœ… Always initialize variables or use `late`

  ```dart
  // âœ… Good
  final String name = 'John';
  late String name;

  // âŒ Error: uninitialized variable
  String name; // Error: 'name' must be initialized
  ```

## Const and Final

### Const

- âœ… Use `const` for values known at compile time
- âœ… Use `const` constructors when possible for better performance
- âœ… Use `const` in immutable widgets

```dart
// âœ… Good: const for fixed values
const int maxRetries = 3;
const Duration timeout = Duration(seconds: 30);

// âœ… Good: const constructor
const Text('Hello');

// âœ… Good: const widget
class MyWidget extends StatelessWidget {
  const MyWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return const Text('Hello');
  }
}
```

### Final

- âœ… Use `final` for variables that won't be reassigned
- âœ… Prefer `final` over `var` when the value doesn't change

```dart
// âœ… Good: final for immutable values
final String userName = 'John';
final List<int> numbers = [1, 2, 3];

// âŒ Avoid: var when final is sufficient
var userName = 'John'; // Should be final
```

## Strings

### Interpolation

- âœ… Use string interpolation instead of concatenation

  ```dart
  // âœ… Good
  String message = 'Hello, $userName!';
  String fullName = '${user.firstName} ${user.lastName}';

  // âŒ Avoid
  String message = 'Hello, ' + userName + '!';
  ```

### Multiline

- âœ… Use triple quotes for multiline strings
  ```dart
  String longText = '''
    This is a
    multiline string
  ''';
  ```

## Collections

### List

- âœ… Use list literals when possible
- âœ… Prefer `List<T>` over untyped `List`

  ```dart
  // âœ… Good: explicit type
  List<String> names = ['John', 'Jane'];

  // âœ… Good: const list
  const List<String> defaultNames = ['John', 'Jane'];

  // âŒ Avoid: untyped
  List names = ['John', 'Jane'];
  ```

### Map

- âœ… Use map literals when possible
- âœ… Prefer `Map<String, T>` over untyped `Map`

  ```dart
  // âœ… Good: explicit type
  Map<String, int> scores = {'John': 100, 'Jane': 95};

  // âŒ Avoid: untyped
  Map scores = {'John': 100, 'Jane': 95};
  ```

### Set

- âœ… Use set literals when possible
  ```dart
  Set<String> uniqueNames = {'John', 'Jane', 'John'}; // {'John', 'Jane'}
  ```

## Functions and Methods

### Positional vs Named Parameters

- âœ… Use positional parameters for required and clear semantics
- âœ… Use named parameters for optional and better readability
- âœ… Use optional positional parameters rarely

```dart
// âœ… Good: required positional parameters
void createUser(String name, String email) { }

// âœ… Good: optional named parameters
void createUser({
  required String name,
  String? email,
  int age = 0,
}) { }

// âœ… Good: optional positional parameters (rarely)
void createUser(String name, [String? email]) { }
```

### Arrow Functions

- âœ… Use arrow functions for simple one-line functions

  ```dart
  // âœ… Good: arrow function
  String getUserName() => 'John';

  // âœ… Good: full function for complex logic
  String getUserName() {
    // complex logic
    return 'John';
  }
  ```

### Tear-off for Widgets

- âœ… **NEVER return Widget from a function** - use tear-off instead
- âœ… Use tear-off to pass widget constructors directly
- âœ… This improves performance and code clarity

```dart
// âŒ Bad: returning Widget from function
Widget buildUserCard(User user) {
  return UserCard(user: user);
}

// Usage
itemBuilder: (context, index) => buildUserCard(users[index])

// âœ… Good: use tear-off
itemBuilder: UserCard.new

// Or with parameters
itemBuilder: (context, index) => UserCard(user: users[index])

// âœ… Good: tear-off for named constructors
builder: UserCard.fromJson

// âœ… Good: tear-off in callbacks
onTap: () => Navigator.push(context, MaterialPageRoute(builder: UserDetailPage.new))
```

## Classes

### Constructors

- âœ… Use named constructors for different ways to create instances
- âœ… Use `super.key` to pass key to widgets
- âœ… Use `required` for required parameters in named constructors

```dart
// âœ… Good: named constructor
class User {
  final String name;
  final String email;

  User({required this.name, required this.email});

  User.anonymous() : name = 'Anonymous', email = '';

  User.fromJson(Map<String, dynamic> json)
      : name = json['name'],
        email = json['email'];
}

// âœ… Good: super.key in widgets
class MyWidget extends StatelessWidget {
  const MyWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
```

### Getters and Setters

- âœ… Prefer getters/setters over methods when appropriate
- âœ… Use getters for calculated values

  ```dart
  class Rectangle {
    final double width;
    final double height;

    Rectangle(this.width, this.height);

    // âœ… Good: getter for calculated value
    double get area => width * height;

    // âœ… Good: getter for derived property
    bool get isSquare => width == height;
  }
  ```

## Dot Shorthands

- âœ… Use dot shorthands for cascade operations and method calls
- âœ… Prefer dot shorthands for cleaner and more readable code
- âœ… Use `..` for cascade operations
- âœ… Use `.` for method calls when appropriate
- âœ… Dart 3.10: use shorthands de tipo (ex.: `.info`, `.new()`, `.first`) quando o tipo Ã© inferido pelo contexto e mantÃ©m legibilidade
- ğŸš« Evite shorthands aninhados ou em contextos onde o tipo nÃ£o estÃ¡ claro; prefira o nome completo para preservar clareza

```dart
// âœ… Good: cascade notation
final user = User()
  ..name = 'John'
  ..email = 'john@example.com'
  ..age = 30;

// âœ… Good: cascade with method calls
final list = <int>[]
  ..add(1)
  ..add(2)
  ..add(3);

// âœ… Good: cascade for builder pattern
final button = ElevatedButton(
  onPressed: () {},
  child: const Text('Click'),
)..style = ButtonStyle(
    backgroundColor: MaterialStateProperty.all(Colors.blue),
  );

// âœ… Good: dot shorthand for method calls
final numbers = [1, 2, 3];
numbers.map((n) => n * 2).toList();

// âœ… Good: dot shorthand with null-aware operators
user?.name?.toUpperCase();
```

## Imports

### Import Order

1. Dart SDK imports
2. Flutter imports
3. External package imports
4. Relative imports (same package)

```dart
// 1. Dart SDK
import 'dart:async';
import 'dart:convert';

// 2. Flutter
import 'package:flutter/material.dart';

// 3. External packages
import 'package:http/http.dart' as http;
import 'package:get_it/get_it.dart';

// 4. Relative
import '../models/user.dart';
import 'user_service.dart';
```

### As Clauses

- âœ… Use `as` to avoid name conflicts
  ```dart
  import 'package:http/http.dart' as http;
  import 'package:logger/logger.dart' as logger;
  ```

### Show/Hide

- âœ… Use `show` to import only what's necessary
  ```dart
  import 'package:my_package/my_package.dart' show User, UserService;
  ```

## Comments and Documentation

### Important Rule: Do Not Create Documentation Automatically

- âŒ **DO NOT create documentation** (`///`, `README.md`, etc.) automatically
- âŒ **DO NOT add unnecessary comments** to code
- âœ… **Only create documentation when explicitly requested** by the user
- âœ… **Code should be self-explanatory** through clear naming

### When to Document (Only if Requested)

- âœ… Use `///` for public API documentation (only when necessary and explicitly requested)
- âœ… Use `//` for internal comments (only when necessary)
- âœ… Document classes, methods, and public parameters only when requested

### Comments

- âœ… Use comments only to explain "why", not "what"
- âœ… Keep comments updated with code
- âœ… Prefer clear code over comments

```dart
// âœ… Good: explains why (important decision)
// Use local cache to reduce API calls by 80%
final cachedUser = await localCache.getUser(id);

// âŒ Avoid: explains what (code already does this)
// Get user from cache
final user = await cache.getUser(id);
```

**Note**: For more detailed documentation rules, see `general_rules.mdc`.

## General Best Practices

### Avoid Dead Code

- âœ… Remove unused commented code
- âœ… Remove unused imports
- âœ… Remove unused variables

### Performance

- âœ… Use `const` constructors when possible
- âœ… Avoid unnecessary rebuilds
- âœ… Use `const` widgets when possible

### Readability

- âœ… Keep functions small and focused
- âœ… Use descriptive names
- âœ… Avoid excessive nesting depth
- âœ… Break long lines (maximum ~80 characters)
